package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i fisherman/internal.ExecutionContext -o ./testing/mocks/execution_context_mock.go

import (
	mm_internal "fisherman/internal"
	"io"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/go-git/go-billy/v5"
	"github.com/gojuno/minimock/v3"
)

// ExecutionContextMock implements internal.ExecutionContext
type ExecutionContextMock struct {
	t minimock.Tester

	funcArg          func(index int) (s1 string, err error)
	inspectFuncArg   func(index int)
	afterArgCounter  uint64
	beforeArgCounter uint64
	ArgMock          mExecutionContextMockArg

	funcArgs          func() (sa1 []string)
	inspectFuncArgs   func()
	afterArgsCounter  uint64
	beforeArgsCounter uint64
	ArgsMock          mExecutionContextMockArgs

	funcCancel          func()
	inspectFuncCancel   func()
	afterCancelCounter  uint64
	beforeCancelCounter uint64
	CancelMock          mExecutionContextMockCancel

	funcDeadline          func() (deadline time.Time, ok bool)
	inspectFuncDeadline   func()
	afterDeadlineCounter  uint64
	beforeDeadlineCounter uint64
	DeadlineMock          mExecutionContextMockDeadline

	funcDone func() (ch1 <-chan struct {
	})
	inspectFuncDone   func()
	afterDoneCounter  uint64
	beforeDoneCounter uint64
	DoneMock          mExecutionContextMockDone

	funcErr          func() (err error)
	inspectFuncErr   func()
	afterErrCounter  uint64
	beforeErrCounter uint64
	ErrMock          mExecutionContextMockErr

	funcFiles          func() (f1 billy.Filesystem)
	inspectFuncFiles   func()
	afterFilesCounter  uint64
	beforeFilesCounter uint64
	FilesMock          mExecutionContextMockFiles

	funcGlobalVariables          func() (m1 map[string]interface{}, err error)
	inspectFuncGlobalVariables   func()
	afterGlobalVariablesCounter  uint64
	beforeGlobalVariablesCounter uint64
	GlobalVariablesMock          mExecutionContextMockGlobalVariables

	funcMessage          func() (s1 string, err error)
	inspectFuncMessage   func()
	afterMessageCounter  uint64
	beforeMessageCounter uint64
	MessageMock          mExecutionContextMockMessage

	funcOutput          func() (w1 io.WriteCloser)
	inspectFuncOutput   func()
	afterOutputCounter  uint64
	beforeOutputCounter uint64
	OutputMock          mExecutionContextMockOutput

	funcRepository          func() (r1 mm_internal.Repository)
	inspectFuncRepository   func()
	afterRepositoryCounter  uint64
	beforeRepositoryCounter uint64
	RepositoryMock          mExecutionContextMockRepository

	funcShell          func() (s1 mm_internal.Shell)
	inspectFuncShell   func()
	afterShellCounter  uint64
	beforeShellCounter uint64
	ShellMock          mExecutionContextMockShell

	funcValue          func(key interface{}) (p1 interface{})
	inspectFuncValue   func(key interface{})
	afterValueCounter  uint64
	beforeValueCounter uint64
	ValueMock          mExecutionContextMockValue
}

// NewExecutionContextMock returns a mock for internal.ExecutionContext
func NewExecutionContextMock(t minimock.Tester) *ExecutionContextMock {
	m := &ExecutionContextMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ArgMock = mExecutionContextMockArg{mock: m}
	m.ArgMock.callArgs = []*ExecutionContextMockArgParams{}

	m.ArgsMock = mExecutionContextMockArgs{mock: m}

	m.CancelMock = mExecutionContextMockCancel{mock: m}

	m.DeadlineMock = mExecutionContextMockDeadline{mock: m}

	m.DoneMock = mExecutionContextMockDone{mock: m}

	m.ErrMock = mExecutionContextMockErr{mock: m}

	m.FilesMock = mExecutionContextMockFiles{mock: m}

	m.GlobalVariablesMock = mExecutionContextMockGlobalVariables{mock: m}

	m.MessageMock = mExecutionContextMockMessage{mock: m}

	m.OutputMock = mExecutionContextMockOutput{mock: m}

	m.RepositoryMock = mExecutionContextMockRepository{mock: m}

	m.ShellMock = mExecutionContextMockShell{mock: m}

	m.ValueMock = mExecutionContextMockValue{mock: m}
	m.ValueMock.callArgs = []*ExecutionContextMockValueParams{}

	return m
}

type mExecutionContextMockArg struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockArgExpectation
	expectations       []*ExecutionContextMockArgExpectation

	callArgs []*ExecutionContextMockArgParams
	mutex    sync.RWMutex
}

// ExecutionContextMockArgExpectation specifies expectation struct of the ExecutionContext.Arg
type ExecutionContextMockArgExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockArgParams
	results *ExecutionContextMockArgResults
	Counter uint64
}

// ExecutionContextMockArgParams contains parameters of the ExecutionContext.Arg
type ExecutionContextMockArgParams struct {
	index int
}

// ExecutionContextMockArgResults contains results of the ExecutionContext.Arg
type ExecutionContextMockArgResults struct {
	s1  string
	err error
}

// Expect sets up expected params for ExecutionContext.Arg
func (mmArg *mExecutionContextMockArg) Expect(index int) *mExecutionContextMockArg {
	if mmArg.mock.funcArg != nil {
		mmArg.mock.t.Fatalf("ExecutionContextMock.Arg mock is already set by Set")
	}

	if mmArg.defaultExpectation == nil {
		mmArg.defaultExpectation = &ExecutionContextMockArgExpectation{}
	}

	mmArg.defaultExpectation.params = &ExecutionContextMockArgParams{index}
	for _, e := range mmArg.expectations {
		if minimock.Equal(e.params, mmArg.defaultExpectation.params) {
			mmArg.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmArg.defaultExpectation.params)
		}
	}

	return mmArg
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.Arg
func (mmArg *mExecutionContextMockArg) Inspect(f func(index int)) *mExecutionContextMockArg {
	if mmArg.mock.inspectFuncArg != nil {
		mmArg.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.Arg")
	}

	mmArg.mock.inspectFuncArg = f

	return mmArg
}

// Return sets up results that will be returned by ExecutionContext.Arg
func (mmArg *mExecutionContextMockArg) Return(s1 string, err error) *ExecutionContextMock {
	if mmArg.mock.funcArg != nil {
		mmArg.mock.t.Fatalf("ExecutionContextMock.Arg mock is already set by Set")
	}

	if mmArg.defaultExpectation == nil {
		mmArg.defaultExpectation = &ExecutionContextMockArgExpectation{mock: mmArg.mock}
	}
	mmArg.defaultExpectation.results = &ExecutionContextMockArgResults{s1, err}
	return mmArg.mock
}

//Set uses given function f to mock the ExecutionContext.Arg method
func (mmArg *mExecutionContextMockArg) Set(f func(index int) (s1 string, err error)) *ExecutionContextMock {
	if mmArg.defaultExpectation != nil {
		mmArg.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.Arg method")
	}

	if len(mmArg.expectations) > 0 {
		mmArg.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.Arg method")
	}

	mmArg.mock.funcArg = f
	return mmArg.mock
}

// When sets expectation for the ExecutionContext.Arg which will trigger the result defined by the following
// Then helper
func (mmArg *mExecutionContextMockArg) When(index int) *ExecutionContextMockArgExpectation {
	if mmArg.mock.funcArg != nil {
		mmArg.mock.t.Fatalf("ExecutionContextMock.Arg mock is already set by Set")
	}

	expectation := &ExecutionContextMockArgExpectation{
		mock:   mmArg.mock,
		params: &ExecutionContextMockArgParams{index},
	}
	mmArg.expectations = append(mmArg.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.Arg return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockArgExpectation) Then(s1 string, err error) *ExecutionContextMock {
	e.results = &ExecutionContextMockArgResults{s1, err}
	return e.mock
}

// Arg implements internal.ExecutionContext
func (mmArg *ExecutionContextMock) Arg(index int) (s1 string, err error) {
	mm_atomic.AddUint64(&mmArg.beforeArgCounter, 1)
	defer mm_atomic.AddUint64(&mmArg.afterArgCounter, 1)

	if mmArg.inspectFuncArg != nil {
		mmArg.inspectFuncArg(index)
	}

	mm_params := &ExecutionContextMockArgParams{index}

	// Record call args
	mmArg.ArgMock.mutex.Lock()
	mmArg.ArgMock.callArgs = append(mmArg.ArgMock.callArgs, mm_params)
	mmArg.ArgMock.mutex.Unlock()

	for _, e := range mmArg.ArgMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmArg.ArgMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmArg.ArgMock.defaultExpectation.Counter, 1)
		mm_want := mmArg.ArgMock.defaultExpectation.params
		mm_got := ExecutionContextMockArgParams{index}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmArg.t.Errorf("ExecutionContextMock.Arg got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmArg.ArgMock.defaultExpectation.results
		if mm_results == nil {
			mmArg.t.Fatal("No results are set for the ExecutionContextMock.Arg")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmArg.funcArg != nil {
		return mmArg.funcArg(index)
	}
	mmArg.t.Fatalf("Unexpected call to ExecutionContextMock.Arg. %v", index)
	return
}

// ArgAfterCounter returns a count of finished ExecutionContextMock.Arg invocations
func (mmArg *ExecutionContextMock) ArgAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmArg.afterArgCounter)
}

// ArgBeforeCounter returns a count of ExecutionContextMock.Arg invocations
func (mmArg *ExecutionContextMock) ArgBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmArg.beforeArgCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.Arg.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmArg *mExecutionContextMockArg) Calls() []*ExecutionContextMockArgParams {
	mmArg.mutex.RLock()

	argCopy := make([]*ExecutionContextMockArgParams, len(mmArg.callArgs))
	copy(argCopy, mmArg.callArgs)

	mmArg.mutex.RUnlock()

	return argCopy
}

// MinimockArgDone returns true if the count of the Arg invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockArgDone() bool {
	for _, e := range m.ArgMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ArgMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterArgCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcArg != nil && mm_atomic.LoadUint64(&m.afterArgCounter) < 1 {
		return false
	}
	return true
}

// MinimockArgInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockArgInspect() {
	for _, e := range m.ArgMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.Arg with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ArgMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterArgCounter) < 1 {
		if m.ArgMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.Arg")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.Arg with params: %#v", *m.ArgMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcArg != nil && mm_atomic.LoadUint64(&m.afterArgCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Arg")
	}
}

type mExecutionContextMockArgs struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockArgsExpectation
	expectations       []*ExecutionContextMockArgsExpectation
}

// ExecutionContextMockArgsExpectation specifies expectation struct of the ExecutionContext.Args
type ExecutionContextMockArgsExpectation struct {
	mock *ExecutionContextMock

	results *ExecutionContextMockArgsResults
	Counter uint64
}

// ExecutionContextMockArgsResults contains results of the ExecutionContext.Args
type ExecutionContextMockArgsResults struct {
	sa1 []string
}

// Expect sets up expected params for ExecutionContext.Args
func (mmArgs *mExecutionContextMockArgs) Expect() *mExecutionContextMockArgs {
	if mmArgs.mock.funcArgs != nil {
		mmArgs.mock.t.Fatalf("ExecutionContextMock.Args mock is already set by Set")
	}

	if mmArgs.defaultExpectation == nil {
		mmArgs.defaultExpectation = &ExecutionContextMockArgsExpectation{}
	}

	return mmArgs
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.Args
func (mmArgs *mExecutionContextMockArgs) Inspect(f func()) *mExecutionContextMockArgs {
	if mmArgs.mock.inspectFuncArgs != nil {
		mmArgs.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.Args")
	}

	mmArgs.mock.inspectFuncArgs = f

	return mmArgs
}

// Return sets up results that will be returned by ExecutionContext.Args
func (mmArgs *mExecutionContextMockArgs) Return(sa1 []string) *ExecutionContextMock {
	if mmArgs.mock.funcArgs != nil {
		mmArgs.mock.t.Fatalf("ExecutionContextMock.Args mock is already set by Set")
	}

	if mmArgs.defaultExpectation == nil {
		mmArgs.defaultExpectation = &ExecutionContextMockArgsExpectation{mock: mmArgs.mock}
	}
	mmArgs.defaultExpectation.results = &ExecutionContextMockArgsResults{sa1}
	return mmArgs.mock
}

//Set uses given function f to mock the ExecutionContext.Args method
func (mmArgs *mExecutionContextMockArgs) Set(f func() (sa1 []string)) *ExecutionContextMock {
	if mmArgs.defaultExpectation != nil {
		mmArgs.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.Args method")
	}

	if len(mmArgs.expectations) > 0 {
		mmArgs.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.Args method")
	}

	mmArgs.mock.funcArgs = f
	return mmArgs.mock
}

// Args implements internal.ExecutionContext
func (mmArgs *ExecutionContextMock) Args() (sa1 []string) {
	mm_atomic.AddUint64(&mmArgs.beforeArgsCounter, 1)
	defer mm_atomic.AddUint64(&mmArgs.afterArgsCounter, 1)

	if mmArgs.inspectFuncArgs != nil {
		mmArgs.inspectFuncArgs()
	}

	if mmArgs.ArgsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmArgs.ArgsMock.defaultExpectation.Counter, 1)

		mm_results := mmArgs.ArgsMock.defaultExpectation.results
		if mm_results == nil {
			mmArgs.t.Fatal("No results are set for the ExecutionContextMock.Args")
		}
		return (*mm_results).sa1
	}
	if mmArgs.funcArgs != nil {
		return mmArgs.funcArgs()
	}
	mmArgs.t.Fatalf("Unexpected call to ExecutionContextMock.Args.")
	return
}

// ArgsAfterCounter returns a count of finished ExecutionContextMock.Args invocations
func (mmArgs *ExecutionContextMock) ArgsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmArgs.afterArgsCounter)
}

// ArgsBeforeCounter returns a count of ExecutionContextMock.Args invocations
func (mmArgs *ExecutionContextMock) ArgsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmArgs.beforeArgsCounter)
}

// MinimockArgsDone returns true if the count of the Args invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockArgsDone() bool {
	for _, e := range m.ArgsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ArgsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterArgsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcArgs != nil && mm_atomic.LoadUint64(&m.afterArgsCounter) < 1 {
		return false
	}
	return true
}

// MinimockArgsInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockArgsInspect() {
	for _, e := range m.ArgsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExecutionContextMock.Args")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ArgsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterArgsCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Args")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcArgs != nil && mm_atomic.LoadUint64(&m.afterArgsCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Args")
	}
}

type mExecutionContextMockCancel struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockCancelExpectation
	expectations       []*ExecutionContextMockCancelExpectation
}

// ExecutionContextMockCancelExpectation specifies expectation struct of the ExecutionContext.Cancel
type ExecutionContextMockCancelExpectation struct {
	mock *ExecutionContextMock

	Counter uint64
}

// Expect sets up expected params for ExecutionContext.Cancel
func (mmCancel *mExecutionContextMockCancel) Expect() *mExecutionContextMockCancel {
	if mmCancel.mock.funcCancel != nil {
		mmCancel.mock.t.Fatalf("ExecutionContextMock.Cancel mock is already set by Set")
	}

	if mmCancel.defaultExpectation == nil {
		mmCancel.defaultExpectation = &ExecutionContextMockCancelExpectation{}
	}

	return mmCancel
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.Cancel
func (mmCancel *mExecutionContextMockCancel) Inspect(f func()) *mExecutionContextMockCancel {
	if mmCancel.mock.inspectFuncCancel != nil {
		mmCancel.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.Cancel")
	}

	mmCancel.mock.inspectFuncCancel = f

	return mmCancel
}

// Return sets up results that will be returned by ExecutionContext.Cancel
func (mmCancel *mExecutionContextMockCancel) Return() *ExecutionContextMock {
	if mmCancel.mock.funcCancel != nil {
		mmCancel.mock.t.Fatalf("ExecutionContextMock.Cancel mock is already set by Set")
	}

	if mmCancel.defaultExpectation == nil {
		mmCancel.defaultExpectation = &ExecutionContextMockCancelExpectation{mock: mmCancel.mock}
	}

	return mmCancel.mock
}

//Set uses given function f to mock the ExecutionContext.Cancel method
func (mmCancel *mExecutionContextMockCancel) Set(f func()) *ExecutionContextMock {
	if mmCancel.defaultExpectation != nil {
		mmCancel.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.Cancel method")
	}

	if len(mmCancel.expectations) > 0 {
		mmCancel.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.Cancel method")
	}

	mmCancel.mock.funcCancel = f
	return mmCancel.mock
}

// Cancel implements internal.ExecutionContext
func (mmCancel *ExecutionContextMock) Cancel() {
	mm_atomic.AddUint64(&mmCancel.beforeCancelCounter, 1)
	defer mm_atomic.AddUint64(&mmCancel.afterCancelCounter, 1)

	if mmCancel.inspectFuncCancel != nil {
		mmCancel.inspectFuncCancel()
	}

	if mmCancel.CancelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCancel.CancelMock.defaultExpectation.Counter, 1)

		return

	}
	if mmCancel.funcCancel != nil {
		mmCancel.funcCancel()
		return
	}
	mmCancel.t.Fatalf("Unexpected call to ExecutionContextMock.Cancel.")

}

// CancelAfterCounter returns a count of finished ExecutionContextMock.Cancel invocations
func (mmCancel *ExecutionContextMock) CancelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancel.afterCancelCounter)
}

// CancelBeforeCounter returns a count of ExecutionContextMock.Cancel invocations
func (mmCancel *ExecutionContextMock) CancelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancel.beforeCancelCounter)
}

// MinimockCancelDone returns true if the count of the Cancel invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockCancelDone() bool {
	for _, e := range m.CancelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CancelMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCancelCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCancel != nil && mm_atomic.LoadUint64(&m.afterCancelCounter) < 1 {
		return false
	}
	return true
}

// MinimockCancelInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockCancelInspect() {
	for _, e := range m.CancelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExecutionContextMock.Cancel")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CancelMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCancelCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Cancel")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCancel != nil && mm_atomic.LoadUint64(&m.afterCancelCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Cancel")
	}
}

type mExecutionContextMockDeadline struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockDeadlineExpectation
	expectations       []*ExecutionContextMockDeadlineExpectation
}

// ExecutionContextMockDeadlineExpectation specifies expectation struct of the ExecutionContext.Deadline
type ExecutionContextMockDeadlineExpectation struct {
	mock *ExecutionContextMock

	results *ExecutionContextMockDeadlineResults
	Counter uint64
}

// ExecutionContextMockDeadlineResults contains results of the ExecutionContext.Deadline
type ExecutionContextMockDeadlineResults struct {
	deadline time.Time
	ok       bool
}

// Expect sets up expected params for ExecutionContext.Deadline
func (mmDeadline *mExecutionContextMockDeadline) Expect() *mExecutionContextMockDeadline {
	if mmDeadline.mock.funcDeadline != nil {
		mmDeadline.mock.t.Fatalf("ExecutionContextMock.Deadline mock is already set by Set")
	}

	if mmDeadline.defaultExpectation == nil {
		mmDeadline.defaultExpectation = &ExecutionContextMockDeadlineExpectation{}
	}

	return mmDeadline
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.Deadline
func (mmDeadline *mExecutionContextMockDeadline) Inspect(f func()) *mExecutionContextMockDeadline {
	if mmDeadline.mock.inspectFuncDeadline != nil {
		mmDeadline.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.Deadline")
	}

	mmDeadline.mock.inspectFuncDeadline = f

	return mmDeadline
}

// Return sets up results that will be returned by ExecutionContext.Deadline
func (mmDeadline *mExecutionContextMockDeadline) Return(deadline time.Time, ok bool) *ExecutionContextMock {
	if mmDeadline.mock.funcDeadline != nil {
		mmDeadline.mock.t.Fatalf("ExecutionContextMock.Deadline mock is already set by Set")
	}

	if mmDeadline.defaultExpectation == nil {
		mmDeadline.defaultExpectation = &ExecutionContextMockDeadlineExpectation{mock: mmDeadline.mock}
	}
	mmDeadline.defaultExpectation.results = &ExecutionContextMockDeadlineResults{deadline, ok}
	return mmDeadline.mock
}

//Set uses given function f to mock the ExecutionContext.Deadline method
func (mmDeadline *mExecutionContextMockDeadline) Set(f func() (deadline time.Time, ok bool)) *ExecutionContextMock {
	if mmDeadline.defaultExpectation != nil {
		mmDeadline.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.Deadline method")
	}

	if len(mmDeadline.expectations) > 0 {
		mmDeadline.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.Deadline method")
	}

	mmDeadline.mock.funcDeadline = f
	return mmDeadline.mock
}

// Deadline implements internal.ExecutionContext
func (mmDeadline *ExecutionContextMock) Deadline() (deadline time.Time, ok bool) {
	mm_atomic.AddUint64(&mmDeadline.beforeDeadlineCounter, 1)
	defer mm_atomic.AddUint64(&mmDeadline.afterDeadlineCounter, 1)

	if mmDeadline.inspectFuncDeadline != nil {
		mmDeadline.inspectFuncDeadline()
	}

	if mmDeadline.DeadlineMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeadline.DeadlineMock.defaultExpectation.Counter, 1)

		mm_results := mmDeadline.DeadlineMock.defaultExpectation.results
		if mm_results == nil {
			mmDeadline.t.Fatal("No results are set for the ExecutionContextMock.Deadline")
		}
		return (*mm_results).deadline, (*mm_results).ok
	}
	if mmDeadline.funcDeadline != nil {
		return mmDeadline.funcDeadline()
	}
	mmDeadline.t.Fatalf("Unexpected call to ExecutionContextMock.Deadline.")
	return
}

// DeadlineAfterCounter returns a count of finished ExecutionContextMock.Deadline invocations
func (mmDeadline *ExecutionContextMock) DeadlineAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeadline.afterDeadlineCounter)
}

// DeadlineBeforeCounter returns a count of ExecutionContextMock.Deadline invocations
func (mmDeadline *ExecutionContextMock) DeadlineBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeadline.beforeDeadlineCounter)
}

// MinimockDeadlineDone returns true if the count of the Deadline invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockDeadlineDone() bool {
	for _, e := range m.DeadlineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeadlineMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeadlineCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeadline != nil && mm_atomic.LoadUint64(&m.afterDeadlineCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeadlineInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockDeadlineInspect() {
	for _, e := range m.DeadlineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExecutionContextMock.Deadline")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeadlineMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeadlineCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Deadline")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeadline != nil && mm_atomic.LoadUint64(&m.afterDeadlineCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Deadline")
	}
}

type mExecutionContextMockDone struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockDoneExpectation
	expectations       []*ExecutionContextMockDoneExpectation
}

// ExecutionContextMockDoneExpectation specifies expectation struct of the ExecutionContext.Done
type ExecutionContextMockDoneExpectation struct {
	mock *ExecutionContextMock

	results *ExecutionContextMockDoneResults
	Counter uint64
}

// ExecutionContextMockDoneResults contains results of the ExecutionContext.Done
type ExecutionContextMockDoneResults struct {
	ch1 <-chan struct {
	}
}

// Expect sets up expected params for ExecutionContext.Done
func (mmDone *mExecutionContextMockDone) Expect() *mExecutionContextMockDone {
	if mmDone.mock.funcDone != nil {
		mmDone.mock.t.Fatalf("ExecutionContextMock.Done mock is already set by Set")
	}

	if mmDone.defaultExpectation == nil {
		mmDone.defaultExpectation = &ExecutionContextMockDoneExpectation{}
	}

	return mmDone
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.Done
func (mmDone *mExecutionContextMockDone) Inspect(f func()) *mExecutionContextMockDone {
	if mmDone.mock.inspectFuncDone != nil {
		mmDone.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.Done")
	}

	mmDone.mock.inspectFuncDone = f

	return mmDone
}

// Return sets up results that will be returned by ExecutionContext.Done
func (mmDone *mExecutionContextMockDone) Return(ch1 <-chan struct {
}) *ExecutionContextMock {
	if mmDone.mock.funcDone != nil {
		mmDone.mock.t.Fatalf("ExecutionContextMock.Done mock is already set by Set")
	}

	if mmDone.defaultExpectation == nil {
		mmDone.defaultExpectation = &ExecutionContextMockDoneExpectation{mock: mmDone.mock}
	}
	mmDone.defaultExpectation.results = &ExecutionContextMockDoneResults{ch1}
	return mmDone.mock
}

//Set uses given function f to mock the ExecutionContext.Done method
func (mmDone *mExecutionContextMockDone) Set(f func() (ch1 <-chan struct {
})) *ExecutionContextMock {
	if mmDone.defaultExpectation != nil {
		mmDone.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.Done method")
	}

	if len(mmDone.expectations) > 0 {
		mmDone.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.Done method")
	}

	mmDone.mock.funcDone = f
	return mmDone.mock
}

// Done implements internal.ExecutionContext
func (mmDone *ExecutionContextMock) Done() (ch1 <-chan struct {
}) {
	mm_atomic.AddUint64(&mmDone.beforeDoneCounter, 1)
	defer mm_atomic.AddUint64(&mmDone.afterDoneCounter, 1)

	if mmDone.inspectFuncDone != nil {
		mmDone.inspectFuncDone()
	}

	if mmDone.DoneMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDone.DoneMock.defaultExpectation.Counter, 1)

		mm_results := mmDone.DoneMock.defaultExpectation.results
		if mm_results == nil {
			mmDone.t.Fatal("No results are set for the ExecutionContextMock.Done")
		}
		return (*mm_results).ch1
	}
	if mmDone.funcDone != nil {
		return mmDone.funcDone()
	}
	mmDone.t.Fatalf("Unexpected call to ExecutionContextMock.Done.")
	return
}

// DoneAfterCounter returns a count of finished ExecutionContextMock.Done invocations
func (mmDone *ExecutionContextMock) DoneAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDone.afterDoneCounter)
}

// DoneBeforeCounter returns a count of ExecutionContextMock.Done invocations
func (mmDone *ExecutionContextMock) DoneBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDone.beforeDoneCounter)
}

// MinimockDoneDone returns true if the count of the Done invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockDoneDone() bool {
	for _, e := range m.DoneMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DoneMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDoneCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDone != nil && mm_atomic.LoadUint64(&m.afterDoneCounter) < 1 {
		return false
	}
	return true
}

// MinimockDoneInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockDoneInspect() {
	for _, e := range m.DoneMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExecutionContextMock.Done")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DoneMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDoneCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Done")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDone != nil && mm_atomic.LoadUint64(&m.afterDoneCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Done")
	}
}

type mExecutionContextMockErr struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockErrExpectation
	expectations       []*ExecutionContextMockErrExpectation
}

// ExecutionContextMockErrExpectation specifies expectation struct of the ExecutionContext.Err
type ExecutionContextMockErrExpectation struct {
	mock *ExecutionContextMock

	results *ExecutionContextMockErrResults
	Counter uint64
}

// ExecutionContextMockErrResults contains results of the ExecutionContext.Err
type ExecutionContextMockErrResults struct {
	err error
}

// Expect sets up expected params for ExecutionContext.Err
func (mmErr *mExecutionContextMockErr) Expect() *mExecutionContextMockErr {
	if mmErr.mock.funcErr != nil {
		mmErr.mock.t.Fatalf("ExecutionContextMock.Err mock is already set by Set")
	}

	if mmErr.defaultExpectation == nil {
		mmErr.defaultExpectation = &ExecutionContextMockErrExpectation{}
	}

	return mmErr
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.Err
func (mmErr *mExecutionContextMockErr) Inspect(f func()) *mExecutionContextMockErr {
	if mmErr.mock.inspectFuncErr != nil {
		mmErr.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.Err")
	}

	mmErr.mock.inspectFuncErr = f

	return mmErr
}

// Return sets up results that will be returned by ExecutionContext.Err
func (mmErr *mExecutionContextMockErr) Return(err error) *ExecutionContextMock {
	if mmErr.mock.funcErr != nil {
		mmErr.mock.t.Fatalf("ExecutionContextMock.Err mock is already set by Set")
	}

	if mmErr.defaultExpectation == nil {
		mmErr.defaultExpectation = &ExecutionContextMockErrExpectation{mock: mmErr.mock}
	}
	mmErr.defaultExpectation.results = &ExecutionContextMockErrResults{err}
	return mmErr.mock
}

//Set uses given function f to mock the ExecutionContext.Err method
func (mmErr *mExecutionContextMockErr) Set(f func() (err error)) *ExecutionContextMock {
	if mmErr.defaultExpectation != nil {
		mmErr.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.Err method")
	}

	if len(mmErr.expectations) > 0 {
		mmErr.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.Err method")
	}

	mmErr.mock.funcErr = f
	return mmErr.mock
}

// Err implements internal.ExecutionContext
func (mmErr *ExecutionContextMock) Err() (err error) {
	mm_atomic.AddUint64(&mmErr.beforeErrCounter, 1)
	defer mm_atomic.AddUint64(&mmErr.afterErrCounter, 1)

	if mmErr.inspectFuncErr != nil {
		mmErr.inspectFuncErr()
	}

	if mmErr.ErrMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmErr.ErrMock.defaultExpectation.Counter, 1)

		mm_results := mmErr.ErrMock.defaultExpectation.results
		if mm_results == nil {
			mmErr.t.Fatal("No results are set for the ExecutionContextMock.Err")
		}
		return (*mm_results).err
	}
	if mmErr.funcErr != nil {
		return mmErr.funcErr()
	}
	mmErr.t.Fatalf("Unexpected call to ExecutionContextMock.Err.")
	return
}

// ErrAfterCounter returns a count of finished ExecutionContextMock.Err invocations
func (mmErr *ExecutionContextMock) ErrAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmErr.afterErrCounter)
}

// ErrBeforeCounter returns a count of ExecutionContextMock.Err invocations
func (mmErr *ExecutionContextMock) ErrBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmErr.beforeErrCounter)
}

// MinimockErrDone returns true if the count of the Err invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockErrDone() bool {
	for _, e := range m.ErrMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ErrMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterErrCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcErr != nil && mm_atomic.LoadUint64(&m.afterErrCounter) < 1 {
		return false
	}
	return true
}

// MinimockErrInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockErrInspect() {
	for _, e := range m.ErrMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExecutionContextMock.Err")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ErrMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterErrCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Err")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcErr != nil && mm_atomic.LoadUint64(&m.afterErrCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Err")
	}
}

type mExecutionContextMockFiles struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockFilesExpectation
	expectations       []*ExecutionContextMockFilesExpectation
}

// ExecutionContextMockFilesExpectation specifies expectation struct of the ExecutionContext.Files
type ExecutionContextMockFilesExpectation struct {
	mock *ExecutionContextMock

	results *ExecutionContextMockFilesResults
	Counter uint64
}

// ExecutionContextMockFilesResults contains results of the ExecutionContext.Files
type ExecutionContextMockFilesResults struct {
	f1 billy.Filesystem
}

// Expect sets up expected params for ExecutionContext.Files
func (mmFiles *mExecutionContextMockFiles) Expect() *mExecutionContextMockFiles {
	if mmFiles.mock.funcFiles != nil {
		mmFiles.mock.t.Fatalf("ExecutionContextMock.Files mock is already set by Set")
	}

	if mmFiles.defaultExpectation == nil {
		mmFiles.defaultExpectation = &ExecutionContextMockFilesExpectation{}
	}

	return mmFiles
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.Files
func (mmFiles *mExecutionContextMockFiles) Inspect(f func()) *mExecutionContextMockFiles {
	if mmFiles.mock.inspectFuncFiles != nil {
		mmFiles.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.Files")
	}

	mmFiles.mock.inspectFuncFiles = f

	return mmFiles
}

// Return sets up results that will be returned by ExecutionContext.Files
func (mmFiles *mExecutionContextMockFiles) Return(f1 billy.Filesystem) *ExecutionContextMock {
	if mmFiles.mock.funcFiles != nil {
		mmFiles.mock.t.Fatalf("ExecutionContextMock.Files mock is already set by Set")
	}

	if mmFiles.defaultExpectation == nil {
		mmFiles.defaultExpectation = &ExecutionContextMockFilesExpectation{mock: mmFiles.mock}
	}
	mmFiles.defaultExpectation.results = &ExecutionContextMockFilesResults{f1}
	return mmFiles.mock
}

//Set uses given function f to mock the ExecutionContext.Files method
func (mmFiles *mExecutionContextMockFiles) Set(f func() (f1 billy.Filesystem)) *ExecutionContextMock {
	if mmFiles.defaultExpectation != nil {
		mmFiles.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.Files method")
	}

	if len(mmFiles.expectations) > 0 {
		mmFiles.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.Files method")
	}

	mmFiles.mock.funcFiles = f
	return mmFiles.mock
}

// Files implements internal.ExecutionContext
func (mmFiles *ExecutionContextMock) Files() (f1 billy.Filesystem) {
	mm_atomic.AddUint64(&mmFiles.beforeFilesCounter, 1)
	defer mm_atomic.AddUint64(&mmFiles.afterFilesCounter, 1)

	if mmFiles.inspectFuncFiles != nil {
		mmFiles.inspectFuncFiles()
	}

	if mmFiles.FilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFiles.FilesMock.defaultExpectation.Counter, 1)

		mm_results := mmFiles.FilesMock.defaultExpectation.results
		if mm_results == nil {
			mmFiles.t.Fatal("No results are set for the ExecutionContextMock.Files")
		}
		return (*mm_results).f1
	}
	if mmFiles.funcFiles != nil {
		return mmFiles.funcFiles()
	}
	mmFiles.t.Fatalf("Unexpected call to ExecutionContextMock.Files.")
	return
}

// FilesAfterCounter returns a count of finished ExecutionContextMock.Files invocations
func (mmFiles *ExecutionContextMock) FilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFiles.afterFilesCounter)
}

// FilesBeforeCounter returns a count of ExecutionContextMock.Files invocations
func (mmFiles *ExecutionContextMock) FilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFiles.beforeFilesCounter)
}

// MinimockFilesDone returns true if the count of the Files invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockFilesDone() bool {
	for _, e := range m.FilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FilesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFilesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFiles != nil && mm_atomic.LoadUint64(&m.afterFilesCounter) < 1 {
		return false
	}
	return true
}

// MinimockFilesInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockFilesInspect() {
	for _, e := range m.FilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExecutionContextMock.Files")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FilesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFilesCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Files")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFiles != nil && mm_atomic.LoadUint64(&m.afterFilesCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Files")
	}
}

type mExecutionContextMockGlobalVariables struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockGlobalVariablesExpectation
	expectations       []*ExecutionContextMockGlobalVariablesExpectation
}

// ExecutionContextMockGlobalVariablesExpectation specifies expectation struct of the ExecutionContext.GlobalVariables
type ExecutionContextMockGlobalVariablesExpectation struct {
	mock *ExecutionContextMock

	results *ExecutionContextMockGlobalVariablesResults
	Counter uint64
}

// ExecutionContextMockGlobalVariablesResults contains results of the ExecutionContext.GlobalVariables
type ExecutionContextMockGlobalVariablesResults struct {
	m1  map[string]interface{}
	err error
}

// Expect sets up expected params for ExecutionContext.GlobalVariables
func (mmGlobalVariables *mExecutionContextMockGlobalVariables) Expect() *mExecutionContextMockGlobalVariables {
	if mmGlobalVariables.mock.funcGlobalVariables != nil {
		mmGlobalVariables.mock.t.Fatalf("ExecutionContextMock.GlobalVariables mock is already set by Set")
	}

	if mmGlobalVariables.defaultExpectation == nil {
		mmGlobalVariables.defaultExpectation = &ExecutionContextMockGlobalVariablesExpectation{}
	}

	return mmGlobalVariables
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.GlobalVariables
func (mmGlobalVariables *mExecutionContextMockGlobalVariables) Inspect(f func()) *mExecutionContextMockGlobalVariables {
	if mmGlobalVariables.mock.inspectFuncGlobalVariables != nil {
		mmGlobalVariables.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.GlobalVariables")
	}

	mmGlobalVariables.mock.inspectFuncGlobalVariables = f

	return mmGlobalVariables
}

// Return sets up results that will be returned by ExecutionContext.GlobalVariables
func (mmGlobalVariables *mExecutionContextMockGlobalVariables) Return(m1 map[string]interface{}, err error) *ExecutionContextMock {
	if mmGlobalVariables.mock.funcGlobalVariables != nil {
		mmGlobalVariables.mock.t.Fatalf("ExecutionContextMock.GlobalVariables mock is already set by Set")
	}

	if mmGlobalVariables.defaultExpectation == nil {
		mmGlobalVariables.defaultExpectation = &ExecutionContextMockGlobalVariablesExpectation{mock: mmGlobalVariables.mock}
	}
	mmGlobalVariables.defaultExpectation.results = &ExecutionContextMockGlobalVariablesResults{m1, err}
	return mmGlobalVariables.mock
}

//Set uses given function f to mock the ExecutionContext.GlobalVariables method
func (mmGlobalVariables *mExecutionContextMockGlobalVariables) Set(f func() (m1 map[string]interface{}, err error)) *ExecutionContextMock {
	if mmGlobalVariables.defaultExpectation != nil {
		mmGlobalVariables.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.GlobalVariables method")
	}

	if len(mmGlobalVariables.expectations) > 0 {
		mmGlobalVariables.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.GlobalVariables method")
	}

	mmGlobalVariables.mock.funcGlobalVariables = f
	return mmGlobalVariables.mock
}

// GlobalVariables implements internal.ExecutionContext
func (mmGlobalVariables *ExecutionContextMock) GlobalVariables() (m1 map[string]interface{}, err error) {
	mm_atomic.AddUint64(&mmGlobalVariables.beforeGlobalVariablesCounter, 1)
	defer mm_atomic.AddUint64(&mmGlobalVariables.afterGlobalVariablesCounter, 1)

	if mmGlobalVariables.inspectFuncGlobalVariables != nil {
		mmGlobalVariables.inspectFuncGlobalVariables()
	}

	if mmGlobalVariables.GlobalVariablesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGlobalVariables.GlobalVariablesMock.defaultExpectation.Counter, 1)

		mm_results := mmGlobalVariables.GlobalVariablesMock.defaultExpectation.results
		if mm_results == nil {
			mmGlobalVariables.t.Fatal("No results are set for the ExecutionContextMock.GlobalVariables")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmGlobalVariables.funcGlobalVariables != nil {
		return mmGlobalVariables.funcGlobalVariables()
	}
	mmGlobalVariables.t.Fatalf("Unexpected call to ExecutionContextMock.GlobalVariables.")
	return
}

// GlobalVariablesAfterCounter returns a count of finished ExecutionContextMock.GlobalVariables invocations
func (mmGlobalVariables *ExecutionContextMock) GlobalVariablesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGlobalVariables.afterGlobalVariablesCounter)
}

// GlobalVariablesBeforeCounter returns a count of ExecutionContextMock.GlobalVariables invocations
func (mmGlobalVariables *ExecutionContextMock) GlobalVariablesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGlobalVariables.beforeGlobalVariablesCounter)
}

// MinimockGlobalVariablesDone returns true if the count of the GlobalVariables invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockGlobalVariablesDone() bool {
	for _, e := range m.GlobalVariablesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GlobalVariablesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGlobalVariablesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGlobalVariables != nil && mm_atomic.LoadUint64(&m.afterGlobalVariablesCounter) < 1 {
		return false
	}
	return true
}

// MinimockGlobalVariablesInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockGlobalVariablesInspect() {
	for _, e := range m.GlobalVariablesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExecutionContextMock.GlobalVariables")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GlobalVariablesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGlobalVariablesCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.GlobalVariables")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGlobalVariables != nil && mm_atomic.LoadUint64(&m.afterGlobalVariablesCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.GlobalVariables")
	}
}

type mExecutionContextMockMessage struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockMessageExpectation
	expectations       []*ExecutionContextMockMessageExpectation
}

// ExecutionContextMockMessageExpectation specifies expectation struct of the ExecutionContext.Message
type ExecutionContextMockMessageExpectation struct {
	mock *ExecutionContextMock

	results *ExecutionContextMockMessageResults
	Counter uint64
}

// ExecutionContextMockMessageResults contains results of the ExecutionContext.Message
type ExecutionContextMockMessageResults struct {
	s1  string
	err error
}

// Expect sets up expected params for ExecutionContext.Message
func (mmMessage *mExecutionContextMockMessage) Expect() *mExecutionContextMockMessage {
	if mmMessage.mock.funcMessage != nil {
		mmMessage.mock.t.Fatalf("ExecutionContextMock.Message mock is already set by Set")
	}

	if mmMessage.defaultExpectation == nil {
		mmMessage.defaultExpectation = &ExecutionContextMockMessageExpectation{}
	}

	return mmMessage
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.Message
func (mmMessage *mExecutionContextMockMessage) Inspect(f func()) *mExecutionContextMockMessage {
	if mmMessage.mock.inspectFuncMessage != nil {
		mmMessage.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.Message")
	}

	mmMessage.mock.inspectFuncMessage = f

	return mmMessage
}

// Return sets up results that will be returned by ExecutionContext.Message
func (mmMessage *mExecutionContextMockMessage) Return(s1 string, err error) *ExecutionContextMock {
	if mmMessage.mock.funcMessage != nil {
		mmMessage.mock.t.Fatalf("ExecutionContextMock.Message mock is already set by Set")
	}

	if mmMessage.defaultExpectation == nil {
		mmMessage.defaultExpectation = &ExecutionContextMockMessageExpectation{mock: mmMessage.mock}
	}
	mmMessage.defaultExpectation.results = &ExecutionContextMockMessageResults{s1, err}
	return mmMessage.mock
}

//Set uses given function f to mock the ExecutionContext.Message method
func (mmMessage *mExecutionContextMockMessage) Set(f func() (s1 string, err error)) *ExecutionContextMock {
	if mmMessage.defaultExpectation != nil {
		mmMessage.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.Message method")
	}

	if len(mmMessage.expectations) > 0 {
		mmMessage.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.Message method")
	}

	mmMessage.mock.funcMessage = f
	return mmMessage.mock
}

// Message implements internal.ExecutionContext
func (mmMessage *ExecutionContextMock) Message() (s1 string, err error) {
	mm_atomic.AddUint64(&mmMessage.beforeMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmMessage.afterMessageCounter, 1)

	if mmMessage.inspectFuncMessage != nil {
		mmMessage.inspectFuncMessage()
	}

	if mmMessage.MessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMessage.MessageMock.defaultExpectation.Counter, 1)

		mm_results := mmMessage.MessageMock.defaultExpectation.results
		if mm_results == nil {
			mmMessage.t.Fatal("No results are set for the ExecutionContextMock.Message")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmMessage.funcMessage != nil {
		return mmMessage.funcMessage()
	}
	mmMessage.t.Fatalf("Unexpected call to ExecutionContextMock.Message.")
	return
}

// MessageAfterCounter returns a count of finished ExecutionContextMock.Message invocations
func (mmMessage *ExecutionContextMock) MessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMessage.afterMessageCounter)
}

// MessageBeforeCounter returns a count of ExecutionContextMock.Message invocations
func (mmMessage *ExecutionContextMock) MessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMessage.beforeMessageCounter)
}

// MinimockMessageDone returns true if the count of the Message invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockMessageDone() bool {
	for _, e := range m.MessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMessageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMessage != nil && mm_atomic.LoadUint64(&m.afterMessageCounter) < 1 {
		return false
	}
	return true
}

// MinimockMessageInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockMessageInspect() {
	for _, e := range m.MessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExecutionContextMock.Message")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMessageCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Message")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMessage != nil && mm_atomic.LoadUint64(&m.afterMessageCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Message")
	}
}

type mExecutionContextMockOutput struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockOutputExpectation
	expectations       []*ExecutionContextMockOutputExpectation
}

// ExecutionContextMockOutputExpectation specifies expectation struct of the ExecutionContext.Output
type ExecutionContextMockOutputExpectation struct {
	mock *ExecutionContextMock

	results *ExecutionContextMockOutputResults
	Counter uint64
}

// ExecutionContextMockOutputResults contains results of the ExecutionContext.Output
type ExecutionContextMockOutputResults struct {
	w1 io.WriteCloser
}

// Expect sets up expected params for ExecutionContext.Output
func (mmOutput *mExecutionContextMockOutput) Expect() *mExecutionContextMockOutput {
	if mmOutput.mock.funcOutput != nil {
		mmOutput.mock.t.Fatalf("ExecutionContextMock.Output mock is already set by Set")
	}

	if mmOutput.defaultExpectation == nil {
		mmOutput.defaultExpectation = &ExecutionContextMockOutputExpectation{}
	}

	return mmOutput
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.Output
func (mmOutput *mExecutionContextMockOutput) Inspect(f func()) *mExecutionContextMockOutput {
	if mmOutput.mock.inspectFuncOutput != nil {
		mmOutput.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.Output")
	}

	mmOutput.mock.inspectFuncOutput = f

	return mmOutput
}

// Return sets up results that will be returned by ExecutionContext.Output
func (mmOutput *mExecutionContextMockOutput) Return(w1 io.WriteCloser) *ExecutionContextMock {
	if mmOutput.mock.funcOutput != nil {
		mmOutput.mock.t.Fatalf("ExecutionContextMock.Output mock is already set by Set")
	}

	if mmOutput.defaultExpectation == nil {
		mmOutput.defaultExpectation = &ExecutionContextMockOutputExpectation{mock: mmOutput.mock}
	}
	mmOutput.defaultExpectation.results = &ExecutionContextMockOutputResults{w1}
	return mmOutput.mock
}

//Set uses given function f to mock the ExecutionContext.Output method
func (mmOutput *mExecutionContextMockOutput) Set(f func() (w1 io.WriteCloser)) *ExecutionContextMock {
	if mmOutput.defaultExpectation != nil {
		mmOutput.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.Output method")
	}

	if len(mmOutput.expectations) > 0 {
		mmOutput.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.Output method")
	}

	mmOutput.mock.funcOutput = f
	return mmOutput.mock
}

// Output implements internal.ExecutionContext
func (mmOutput *ExecutionContextMock) Output() (w1 io.WriteCloser) {
	mm_atomic.AddUint64(&mmOutput.beforeOutputCounter, 1)
	defer mm_atomic.AddUint64(&mmOutput.afterOutputCounter, 1)

	if mmOutput.inspectFuncOutput != nil {
		mmOutput.inspectFuncOutput()
	}

	if mmOutput.OutputMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOutput.OutputMock.defaultExpectation.Counter, 1)

		mm_results := mmOutput.OutputMock.defaultExpectation.results
		if mm_results == nil {
			mmOutput.t.Fatal("No results are set for the ExecutionContextMock.Output")
		}
		return (*mm_results).w1
	}
	if mmOutput.funcOutput != nil {
		return mmOutput.funcOutput()
	}
	mmOutput.t.Fatalf("Unexpected call to ExecutionContextMock.Output.")
	return
}

// OutputAfterCounter returns a count of finished ExecutionContextMock.Output invocations
func (mmOutput *ExecutionContextMock) OutputAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOutput.afterOutputCounter)
}

// OutputBeforeCounter returns a count of ExecutionContextMock.Output invocations
func (mmOutput *ExecutionContextMock) OutputBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOutput.beforeOutputCounter)
}

// MinimockOutputDone returns true if the count of the Output invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockOutputDone() bool {
	for _, e := range m.OutputMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OutputMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOutputCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOutput != nil && mm_atomic.LoadUint64(&m.afterOutputCounter) < 1 {
		return false
	}
	return true
}

// MinimockOutputInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockOutputInspect() {
	for _, e := range m.OutputMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExecutionContextMock.Output")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OutputMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOutputCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Output")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOutput != nil && mm_atomic.LoadUint64(&m.afterOutputCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Output")
	}
}

type mExecutionContextMockRepository struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockRepositoryExpectation
	expectations       []*ExecutionContextMockRepositoryExpectation
}

// ExecutionContextMockRepositoryExpectation specifies expectation struct of the ExecutionContext.Repository
type ExecutionContextMockRepositoryExpectation struct {
	mock *ExecutionContextMock

	results *ExecutionContextMockRepositoryResults
	Counter uint64
}

// ExecutionContextMockRepositoryResults contains results of the ExecutionContext.Repository
type ExecutionContextMockRepositoryResults struct {
	r1 mm_internal.Repository
}

// Expect sets up expected params for ExecutionContext.Repository
func (mmRepository *mExecutionContextMockRepository) Expect() *mExecutionContextMockRepository {
	if mmRepository.mock.funcRepository != nil {
		mmRepository.mock.t.Fatalf("ExecutionContextMock.Repository mock is already set by Set")
	}

	if mmRepository.defaultExpectation == nil {
		mmRepository.defaultExpectation = &ExecutionContextMockRepositoryExpectation{}
	}

	return mmRepository
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.Repository
func (mmRepository *mExecutionContextMockRepository) Inspect(f func()) *mExecutionContextMockRepository {
	if mmRepository.mock.inspectFuncRepository != nil {
		mmRepository.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.Repository")
	}

	mmRepository.mock.inspectFuncRepository = f

	return mmRepository
}

// Return sets up results that will be returned by ExecutionContext.Repository
func (mmRepository *mExecutionContextMockRepository) Return(r1 mm_internal.Repository) *ExecutionContextMock {
	if mmRepository.mock.funcRepository != nil {
		mmRepository.mock.t.Fatalf("ExecutionContextMock.Repository mock is already set by Set")
	}

	if mmRepository.defaultExpectation == nil {
		mmRepository.defaultExpectation = &ExecutionContextMockRepositoryExpectation{mock: mmRepository.mock}
	}
	mmRepository.defaultExpectation.results = &ExecutionContextMockRepositoryResults{r1}
	return mmRepository.mock
}

//Set uses given function f to mock the ExecutionContext.Repository method
func (mmRepository *mExecutionContextMockRepository) Set(f func() (r1 mm_internal.Repository)) *ExecutionContextMock {
	if mmRepository.defaultExpectation != nil {
		mmRepository.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.Repository method")
	}

	if len(mmRepository.expectations) > 0 {
		mmRepository.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.Repository method")
	}

	mmRepository.mock.funcRepository = f
	return mmRepository.mock
}

// Repository implements internal.ExecutionContext
func (mmRepository *ExecutionContextMock) Repository() (r1 mm_internal.Repository) {
	mm_atomic.AddUint64(&mmRepository.beforeRepositoryCounter, 1)
	defer mm_atomic.AddUint64(&mmRepository.afterRepositoryCounter, 1)

	if mmRepository.inspectFuncRepository != nil {
		mmRepository.inspectFuncRepository()
	}

	if mmRepository.RepositoryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRepository.RepositoryMock.defaultExpectation.Counter, 1)

		mm_results := mmRepository.RepositoryMock.defaultExpectation.results
		if mm_results == nil {
			mmRepository.t.Fatal("No results are set for the ExecutionContextMock.Repository")
		}
		return (*mm_results).r1
	}
	if mmRepository.funcRepository != nil {
		return mmRepository.funcRepository()
	}
	mmRepository.t.Fatalf("Unexpected call to ExecutionContextMock.Repository.")
	return
}

// RepositoryAfterCounter returns a count of finished ExecutionContextMock.Repository invocations
func (mmRepository *ExecutionContextMock) RepositoryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRepository.afterRepositoryCounter)
}

// RepositoryBeforeCounter returns a count of ExecutionContextMock.Repository invocations
func (mmRepository *ExecutionContextMock) RepositoryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRepository.beforeRepositoryCounter)
}

// MinimockRepositoryDone returns true if the count of the Repository invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockRepositoryDone() bool {
	for _, e := range m.RepositoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RepositoryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRepositoryCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRepository != nil && mm_atomic.LoadUint64(&m.afterRepositoryCounter) < 1 {
		return false
	}
	return true
}

// MinimockRepositoryInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockRepositoryInspect() {
	for _, e := range m.RepositoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExecutionContextMock.Repository")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RepositoryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRepositoryCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Repository")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRepository != nil && mm_atomic.LoadUint64(&m.afterRepositoryCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Repository")
	}
}

type mExecutionContextMockShell struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockShellExpectation
	expectations       []*ExecutionContextMockShellExpectation
}

// ExecutionContextMockShellExpectation specifies expectation struct of the ExecutionContext.Shell
type ExecutionContextMockShellExpectation struct {
	mock *ExecutionContextMock

	results *ExecutionContextMockShellResults
	Counter uint64
}

// ExecutionContextMockShellResults contains results of the ExecutionContext.Shell
type ExecutionContextMockShellResults struct {
	s1 mm_internal.Shell
}

// Expect sets up expected params for ExecutionContext.Shell
func (mmShell *mExecutionContextMockShell) Expect() *mExecutionContextMockShell {
	if mmShell.mock.funcShell != nil {
		mmShell.mock.t.Fatalf("ExecutionContextMock.Shell mock is already set by Set")
	}

	if mmShell.defaultExpectation == nil {
		mmShell.defaultExpectation = &ExecutionContextMockShellExpectation{}
	}

	return mmShell
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.Shell
func (mmShell *mExecutionContextMockShell) Inspect(f func()) *mExecutionContextMockShell {
	if mmShell.mock.inspectFuncShell != nil {
		mmShell.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.Shell")
	}

	mmShell.mock.inspectFuncShell = f

	return mmShell
}

// Return sets up results that will be returned by ExecutionContext.Shell
func (mmShell *mExecutionContextMockShell) Return(s1 mm_internal.Shell) *ExecutionContextMock {
	if mmShell.mock.funcShell != nil {
		mmShell.mock.t.Fatalf("ExecutionContextMock.Shell mock is already set by Set")
	}

	if mmShell.defaultExpectation == nil {
		mmShell.defaultExpectation = &ExecutionContextMockShellExpectation{mock: mmShell.mock}
	}
	mmShell.defaultExpectation.results = &ExecutionContextMockShellResults{s1}
	return mmShell.mock
}

//Set uses given function f to mock the ExecutionContext.Shell method
func (mmShell *mExecutionContextMockShell) Set(f func() (s1 mm_internal.Shell)) *ExecutionContextMock {
	if mmShell.defaultExpectation != nil {
		mmShell.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.Shell method")
	}

	if len(mmShell.expectations) > 0 {
		mmShell.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.Shell method")
	}

	mmShell.mock.funcShell = f
	return mmShell.mock
}

// Shell implements internal.ExecutionContext
func (mmShell *ExecutionContextMock) Shell() (s1 mm_internal.Shell) {
	mm_atomic.AddUint64(&mmShell.beforeShellCounter, 1)
	defer mm_atomic.AddUint64(&mmShell.afterShellCounter, 1)

	if mmShell.inspectFuncShell != nil {
		mmShell.inspectFuncShell()
	}

	if mmShell.ShellMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmShell.ShellMock.defaultExpectation.Counter, 1)

		mm_results := mmShell.ShellMock.defaultExpectation.results
		if mm_results == nil {
			mmShell.t.Fatal("No results are set for the ExecutionContextMock.Shell")
		}
		return (*mm_results).s1
	}
	if mmShell.funcShell != nil {
		return mmShell.funcShell()
	}
	mmShell.t.Fatalf("Unexpected call to ExecutionContextMock.Shell.")
	return
}

// ShellAfterCounter returns a count of finished ExecutionContextMock.Shell invocations
func (mmShell *ExecutionContextMock) ShellAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShell.afterShellCounter)
}

// ShellBeforeCounter returns a count of ExecutionContextMock.Shell invocations
func (mmShell *ExecutionContextMock) ShellBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShell.beforeShellCounter)
}

// MinimockShellDone returns true if the count of the Shell invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockShellDone() bool {
	for _, e := range m.ShellMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ShellMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterShellCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcShell != nil && mm_atomic.LoadUint64(&m.afterShellCounter) < 1 {
		return false
	}
	return true
}

// MinimockShellInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockShellInspect() {
	for _, e := range m.ShellMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExecutionContextMock.Shell")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ShellMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterShellCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Shell")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcShell != nil && mm_atomic.LoadUint64(&m.afterShellCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Shell")
	}
}

type mExecutionContextMockValue struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockValueExpectation
	expectations       []*ExecutionContextMockValueExpectation

	callArgs []*ExecutionContextMockValueParams
	mutex    sync.RWMutex
}

// ExecutionContextMockValueExpectation specifies expectation struct of the ExecutionContext.Value
type ExecutionContextMockValueExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockValueParams
	results *ExecutionContextMockValueResults
	Counter uint64
}

// ExecutionContextMockValueParams contains parameters of the ExecutionContext.Value
type ExecutionContextMockValueParams struct {
	key interface{}
}

// ExecutionContextMockValueResults contains results of the ExecutionContext.Value
type ExecutionContextMockValueResults struct {
	p1 interface{}
}

// Expect sets up expected params for ExecutionContext.Value
func (mmValue *mExecutionContextMockValue) Expect(key interface{}) *mExecutionContextMockValue {
	if mmValue.mock.funcValue != nil {
		mmValue.mock.t.Fatalf("ExecutionContextMock.Value mock is already set by Set")
	}

	if mmValue.defaultExpectation == nil {
		mmValue.defaultExpectation = &ExecutionContextMockValueExpectation{}
	}

	mmValue.defaultExpectation.params = &ExecutionContextMockValueParams{key}
	for _, e := range mmValue.expectations {
		if minimock.Equal(e.params, mmValue.defaultExpectation.params) {
			mmValue.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmValue.defaultExpectation.params)
		}
	}

	return mmValue
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.Value
func (mmValue *mExecutionContextMockValue) Inspect(f func(key interface{})) *mExecutionContextMockValue {
	if mmValue.mock.inspectFuncValue != nil {
		mmValue.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.Value")
	}

	mmValue.mock.inspectFuncValue = f

	return mmValue
}

// Return sets up results that will be returned by ExecutionContext.Value
func (mmValue *mExecutionContextMockValue) Return(p1 interface{}) *ExecutionContextMock {
	if mmValue.mock.funcValue != nil {
		mmValue.mock.t.Fatalf("ExecutionContextMock.Value mock is already set by Set")
	}

	if mmValue.defaultExpectation == nil {
		mmValue.defaultExpectation = &ExecutionContextMockValueExpectation{mock: mmValue.mock}
	}
	mmValue.defaultExpectation.results = &ExecutionContextMockValueResults{p1}
	return mmValue.mock
}

//Set uses given function f to mock the ExecutionContext.Value method
func (mmValue *mExecutionContextMockValue) Set(f func(key interface{}) (p1 interface{})) *ExecutionContextMock {
	if mmValue.defaultExpectation != nil {
		mmValue.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.Value method")
	}

	if len(mmValue.expectations) > 0 {
		mmValue.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.Value method")
	}

	mmValue.mock.funcValue = f
	return mmValue.mock
}

// When sets expectation for the ExecutionContext.Value which will trigger the result defined by the following
// Then helper
func (mmValue *mExecutionContextMockValue) When(key interface{}) *ExecutionContextMockValueExpectation {
	if mmValue.mock.funcValue != nil {
		mmValue.mock.t.Fatalf("ExecutionContextMock.Value mock is already set by Set")
	}

	expectation := &ExecutionContextMockValueExpectation{
		mock:   mmValue.mock,
		params: &ExecutionContextMockValueParams{key},
	}
	mmValue.expectations = append(mmValue.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.Value return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockValueExpectation) Then(p1 interface{}) *ExecutionContextMock {
	e.results = &ExecutionContextMockValueResults{p1}
	return e.mock
}

// Value implements internal.ExecutionContext
func (mmValue *ExecutionContextMock) Value(key interface{}) (p1 interface{}) {
	mm_atomic.AddUint64(&mmValue.beforeValueCounter, 1)
	defer mm_atomic.AddUint64(&mmValue.afterValueCounter, 1)

	if mmValue.inspectFuncValue != nil {
		mmValue.inspectFuncValue(key)
	}

	mm_params := &ExecutionContextMockValueParams{key}

	// Record call args
	mmValue.ValueMock.mutex.Lock()
	mmValue.ValueMock.callArgs = append(mmValue.ValueMock.callArgs, mm_params)
	mmValue.ValueMock.mutex.Unlock()

	for _, e := range mmValue.ValueMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1
		}
	}

	if mmValue.ValueMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmValue.ValueMock.defaultExpectation.Counter, 1)
		mm_want := mmValue.ValueMock.defaultExpectation.params
		mm_got := ExecutionContextMockValueParams{key}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmValue.t.Errorf("ExecutionContextMock.Value got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmValue.ValueMock.defaultExpectation.results
		if mm_results == nil {
			mmValue.t.Fatal("No results are set for the ExecutionContextMock.Value")
		}
		return (*mm_results).p1
	}
	if mmValue.funcValue != nil {
		return mmValue.funcValue(key)
	}
	mmValue.t.Fatalf("Unexpected call to ExecutionContextMock.Value. %v", key)
	return
}

// ValueAfterCounter returns a count of finished ExecutionContextMock.Value invocations
func (mmValue *ExecutionContextMock) ValueAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValue.afterValueCounter)
}

// ValueBeforeCounter returns a count of ExecutionContextMock.Value invocations
func (mmValue *ExecutionContextMock) ValueBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValue.beforeValueCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.Value.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmValue *mExecutionContextMockValue) Calls() []*ExecutionContextMockValueParams {
	mmValue.mutex.RLock()

	argCopy := make([]*ExecutionContextMockValueParams, len(mmValue.callArgs))
	copy(argCopy, mmValue.callArgs)

	mmValue.mutex.RUnlock()

	return argCopy
}

// MinimockValueDone returns true if the count of the Value invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockValueDone() bool {
	for _, e := range m.ValueMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ValueMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterValueCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcValue != nil && mm_atomic.LoadUint64(&m.afterValueCounter) < 1 {
		return false
	}
	return true
}

// MinimockValueInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockValueInspect() {
	for _, e := range m.ValueMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.Value with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ValueMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterValueCounter) < 1 {
		if m.ValueMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.Value")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.Value with params: %#v", *m.ValueMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcValue != nil && mm_atomic.LoadUint64(&m.afterValueCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Value")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ExecutionContextMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockArgInspect()

		m.MinimockArgsInspect()

		m.MinimockCancelInspect()

		m.MinimockDeadlineInspect()

		m.MinimockDoneInspect()

		m.MinimockErrInspect()

		m.MinimockFilesInspect()

		m.MinimockGlobalVariablesInspect()

		m.MinimockMessageInspect()

		m.MinimockOutputInspect()

		m.MinimockRepositoryInspect()

		m.MinimockShellInspect()

		m.MinimockValueInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ExecutionContextMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ExecutionContextMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockArgDone() &&
		m.MinimockArgsDone() &&
		m.MinimockCancelDone() &&
		m.MinimockDeadlineDone() &&
		m.MinimockDoneDone() &&
		m.MinimockErrDone() &&
		m.MinimockFilesDone() &&
		m.MinimockGlobalVariablesDone() &&
		m.MinimockMessageDone() &&
		m.MinimockOutputDone() &&
		m.MinimockRepositoryDone() &&
		m.MinimockShellDone() &&
		m.MinimockValueDone()
}
